import * as vscode from 'vscode';
import { WorkerManager } from './workerManager';
import { DocPilotPanel, DocumentSource } from './docPilotPanel';

export interface RetrievalResult {
  chunks: Array<{
    chunk: any;
    score: number;
    url: string;
    headings: string[];
  }>;
  totalFound: number;
  queryTime: number;
}

/**
 * ContextAugmenter provides the core functionality for augmenting Copilot conversations
 * with relevant documentation context based on user-selected sources.
 */
export class ContextAugmenter {
  private readonly workerManager: WorkerManager;
  private readonly outputChannel: vscode.OutputChannel;
  private docPilotPanel: DocPilotPanel | null = null;

  constructor(workerManager: WorkerManager, outputChannel: vscode.OutputChannel) {
    this.workerManager = workerManager;
    this.outputChannel = outputChannel;
  }

  public setPanel(panel: DocPilotPanel) {
    this.docPilotPanel = panel;
  }

  /**
   * Register context augmentation with VS Code's chat system
   */
  public register(context: vscode.ExtensionContext): void {
    // Register a simple participant for fallback
    const participant = vscode.chat.createChatParticipant(
      'docpilot.context', 
      this.handleContextRequest.bind(this)
    );
    
    participant.iconPath = vscode.Uri.joinPath(context.extensionUri, 'assets', 'icon.png');
    participant.followupProvider = {
      provideFollowups: this.provideFollowups.bind(this)
    };

    context.subscriptions.push(participant);



    // Auto-inject context via configuration resolver (for workspace variables)
    this.registerContextVariables(context);

    this.outputChannel.appendLine('[context-augmenter] Context augmentation registered');
  }

  /**
   * Register DocPilot context as workspace variables that can be used in any chat
   */
  private registerContextVariables(context: vscode.ExtensionContext): void {
    // Use the configuration resolver service to contribute variables
    // This is a more direct approach to make context available globally
    const configResolver = vscode.extensions.getExtension('vscode.extension-docpilot')?.exports?.configurationResolver;
    
    if (configResolver) {
      configResolver.contributeVariable('docpilot.context', async () => {
        try {
          if (!this.docPilotPanel) return undefined;
          
          const enabledSources = this.docPilotPanel.getEnabledSources();
          if (enabledSources.length === 0) return undefined;
          
          const retrievalResult = await this.retrieveContext('documentation context', enabledSources);
          if (retrievalResult.chunks.length === 0) return undefined;
          
          return this.formatContextAsText(retrievalResult, 3);
        } catch (error) {
          this.outputChannel.appendLine(`[context-augmenter] Variable resolution error: ${error}`);
          return undefined;
        }
      });
      
      this.outputChannel.appendLine('[context-augmenter] Registered ${docpilot.context} variable');
    }

    // Also try to register as workspace file for Copilot to discover
    this.createContextWorkspaceFile(context);
  }

  /**
   * Create a workspace file that Copilot can automatically discover and use as context
   */
  private async createContextWorkspaceFile(context: vscode.ExtensionContext): Promise<void> {
    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
    if (!workspaceFolder) return;

    // Create a .vscode folder if it doesn't exist
    const vscodeFolderUri = vscode.Uri.joinPath(workspaceFolder.uri, '.vscode');
    try {
      await vscode.workspace.fs.stat(vscodeFolderUri);
    } catch {
      await vscode.workspace.fs.createDirectory(vscodeFolderUri);
    }

    // Create a context file that updates automatically
    const contextFileUri = vscode.Uri.joinPath(vscodeFolderUri, 'docpilot-context.md');
    
    // Watch for changes to update the context file
    const updateContextFile = async () => {
      try {
        if (!this.docPilotPanel) return;
        
        const enabledSources = this.docPilotPanel.getEnabledSources();
        if (enabledSources.length === 0) {
          // Remove context file if no sources
          try {
            await vscode.workspace.fs.delete(contextFileUri);
          } catch { /* ignore */ }
          return;
        }
        
        const retrievalResult = await this.retrieveContext('comprehensive documentation context', enabledSources);
        if (retrievalResult.chunks.length === 0) return;
        
        const contextContent = `# DocPilot Context

This file contains documentation context automatically provided by DocPilot.
It is updated when documentation sources change and is automatically available to Copilot.

${this.formatContextAsText(retrievalResult, 5)}

---
*Auto-generated by DocPilot extension*
`;

        await vscode.workspace.fs.writeFile(contextFileUri, Buffer.from(contextContent, 'utf8'));
        this.outputChannel.appendLine('[context-augmenter] Updated workspace context file');
      } catch (error) {
        this.outputChannel.appendLine(`[context-augmenter] Failed to update context file: ${error}`);
      }
    };

    // Update on startup
    setTimeout(updateContextFile, 2000);
    
    // Update when panel changes (we'd need to add this event to DocPilotPanel)
    // For now, update periodically
    setInterval(updateContextFile, 30000); // Every 30 seconds
  }  

  /**
   * Handle context requests - generate markdown context for user to attach
   */
  private async handleContextRequest(
    request: vscode.ChatRequest,
    context: vscode.ChatContext,
    stream: vscode.ChatResponseStream,
    token: vscode.CancellationToken
  ): Promise<vscode.ChatResult> {
    try {
      if (!this.docPilotPanel) {
        stream.markdown(`üöÄ **DocPilot Context Generator**

Please open the DocPilot panel first to configure documentation sources.

Run: \`DocPilot: Open Panel\` command`);
        return { metadata: { command: 'docpilot.context' } };
      }

      const settings = this.docPilotPanel.getAugmentationSettings();
      const enabledSources = this.docPilotPanel.getEnabledSources();

      if (!settings.enabled) {
        stream.markdown(`üîÑ **Context generation is disabled**

Please enable it in the DocPilot panel settings.`);
        return { metadata: { command: 'docpilot.context' } };
      }

      if (enabledSources.length === 0) {
        stream.markdown(`üìö **No documentation sources configured**

Please add and enable documentation sources in the DocPilot panel first.`);
        return { metadata: { command: 'docpilot.context' } };
      }

      stream.progress('üîç Searching documentation...');

      const retrievalResult = await this.retrieveContext(request.prompt, enabledSources);

      if (retrievalResult.chunks.length === 0) {
        stream.markdown(`‚ùå **No relevant documentation found**

Try different keywords or add more documentation sources.`);
        return { metadata: { command: 'docpilot.context' } };
      }

      // Generate formatted markdown context
      const contextText = this.formatContextAsText(retrievalResult, Math.min(settings.maxChunks, retrievalResult.chunks.length));
      
      // Create a local markdown file
      const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
      if (!workspaceFolder) {
        stream.markdown(`‚ùå **No workspace folder found**

Please open a workspace folder first.`);
        return { metadata: { command: 'docpilot.context', error: 'No workspace' } };
      }

      // Create filename with timestamp and sanitized query
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
      const sanitizedQuery = request.prompt.replace(/[^a-zA-Z0-9-_]/g, '-').slice(0, 50);
      const filename = `docpilot-context-${sanitizedQuery}-${timestamp}.md`;
      const filePath = vscode.Uri.joinPath(workspaceFolder.uri, filename);

      try {
        await vscode.workspace.fs.writeFile(filePath, Buffer.from(contextText, 'utf8'));
        
        // Show success message with clickable file link
        stream.markdown(`‚úÖ **Context saved to file**

üìÑ [${filename}](${filePath.toString()})

*Click the file link above to open it, then copy the contents to attach to your Copilot chat.*`);
        
        // Optionally open the file automatically
        const doc = await vscode.workspace.openTextDocument(filePath);
        await vscode.window.showTextDocument(doc, vscode.ViewColumn.Beside);
        
      } catch (error) {
        stream.markdown(`‚ùå **Failed to save file:** ${error instanceof Error ? error.message : String(error)}`);
        // Fallback to showing in chat if file creation fails
        stream.markdown(`

**Fallback - Copy this markdown:**

\`\`\`markdown
`);
        stream.markdown(contextText.replace(/\n/g, '\\n'));
        stream.markdown(`
\`\`\``);
      }

      return {
        metadata: {
          command: 'docpilot.context',
          retrievalTime: retrievalResult.queryTime,
          totalChunks: retrievalResult.totalFound,
          sources: enabledSources.map(s => s.name),
          contextText: contextText
        }
      };

    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      stream.markdown(`‚ùå **Error generating context:** ${message}`);
      this.outputChannel.appendLine(`[context-augmenter] Error: ${message}`);
      
      return { metadata: { command: 'docpilot.context', error: message } };
    }
  }



  /**
   * Retrieve relevant context from enabled documentation sources
   */
  private async retrieveContext(query: string, enabledSources: DocumentSource[]): Promise<RetrievalResult> {
    // Use UI settings for limiting results
    const settings = this.docPilotPanel?.getAugmentationSettings() || { maxChunks: 5, enabled: true };
    
    this.outputChannel.appendLine(`[context-augmenter] Querying with: "${query}"`);
    this.outputChannel.appendLine(`[context-augmenter] Enabled sources: ${enabledSources.map(s => s.name).join(', ')}`);
    
    try {
      const result = await this.workerManager.query(query, undefined, settings.maxChunks * 3);
      
      this.outputChannel.appendLine(`[context-augmenter] Query returned ${result.chunks.length} total chunks`);
      
      // Filter results to only include enabled sources
      const enabledUrls = new Set(enabledSources.map(s => new URL(s.url).origin));
      const filteredChunks = result.chunks.filter(chunk => {
        try {
          const chunkOrigin = new URL(chunk.url).origin;
          const included = enabledUrls.has(chunkOrigin);
          if (!included) {
            this.outputChannel.appendLine(`[context-augmenter] Excluding chunk from ${chunkOrigin} (not in enabled sources)`);
          }
          return included;
        } catch {
          this.outputChannel.appendLine(`[context-augmenter] Excluding chunk with invalid URL: ${chunk.url}`);
          return false; // Invalid URL, exclude
        }
      });

      this.outputChannel.appendLine(`[context-augmenter] Filtered to ${filteredChunks.length} chunks from enabled sources`);
      
      // Limit results based on UI settings
      const limitedChunks = filteredChunks.slice(0, settings.maxChunks * 2); // Get extra for better quality

      return {
        chunks: limitedChunks.map(chunk => ({
          chunk: {
            text: chunk.text,
            wordCount: chunk.text.split(' ').length
          },
          score: chunk.score,
          url: chunk.url,
          headings: chunk.headings || []
        })),
        totalFound: filteredChunks.length,
        queryTime: result.queryTime
      };
    } catch (error) {
      this.outputChannel.appendLine(`[context-augmenter] Query failed: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  /**
   * Format retrieval results as plain text for copying
   */
  private formatContextAsText(retrievalResult: RetrievalResult, maxChunks: number): string {
    const chunks = retrievalResult.chunks.slice(0, maxChunks);
    
    const contextText = chunks.map((item, index) => {
      const heading = item.headings.length > 0 ? item.headings.join(' > ') : 'Documentation';
      return `## Context ${index + 1}: ${heading}\n\n${item.chunk.text}\n\n*Source: ${item.url}*\n*Relevance: ${(item.score * 100).toFixed(1)}%*`;
    }).join('\n\n---\n\n');

    return `# Documentation Context\n\nFound ${retrievalResult.totalFound} documentation matches:\n\n${contextText}`;
  }

  /**
   * Provide followup suggestions
   */
  private provideFollowups(
    result: vscode.ChatResult,
    context: vscode.ChatContext,
    token: vscode.CancellationToken
  ): vscode.ProviderResult<vscode.ChatFollowup[]> {
    if (result.metadata?.command === 'docpilot.query') {
      const followups: vscode.ChatFollowup[] = [
        {
          prompt: 'Show me code examples from these docs #docpilot',
          label: 'üîç Code Examples'
        },
        {
          prompt: 'Explain the API patterns mentioned #docpilot',
          label: 'üìñ API Patterns'
        },
        {
          prompt: 'What are the best practices? #docpilot',
          label: '‚ú® Best Practices'
        }
      ];

      // Add source-specific followups if available
      if (result.metadata?.sources && Array.isArray(result.metadata.sources)) {
        followups.push({
          prompt: `Tell me more about ${result.metadata.sources.join(', ')} #docpilot`,
          label: 'üìö Source Details'
        });
      }

      return followups;
    }

    return [];
  }

  /**
   * Truncate text to specified length with ellipsis
   */
  private truncateText(text: string, maxLength: number): string {
    if (text.length <= maxLength) {
      return text;
    }
    return text.substring(0, maxLength).trim() + '...';
  }

  /**
   * Public method to augment any prompt with documentation context
   * This can be used by other parts of the extension
   */
  public async augmentPrompt(originalPrompt: string, maxContextChunks: number = 3): Promise<string> {
    try {
      if (!this.docPilotPanel) {
        return originalPrompt;
      }

      const settings = this.docPilotPanel.getAugmentationSettings();
      if (!settings.enabled) {
        return originalPrompt;
      }

      const enabledSources = this.docPilotPanel.getEnabledSources();
      if (enabledSources.length === 0) {
        return originalPrompt;
      }

      const retrievalResult = await this.retrieveContext(originalPrompt, enabledSources);
      
      if (retrievalResult.chunks.length === 0) {
        return originalPrompt;
      }

      const contextChunks = retrievalResult.chunks
        .slice(0, maxContextChunks)
        .map((item, index) => {
          const heading = item.headings.length > 0 ? item.headings.join(' > ') : 'Documentation';
          return `## Context ${index + 1}: ${heading}\\n${item.chunk.text}\\n*Source: ${item.url}*`;
        })
        .join('\\n\\n');

      const contextPrefix = `# Documentation Context\\n\\n${contextChunks}\\n\\n---\\n\\n`;
      
      return `${contextPrefix}${originalPrompt}`;

    } catch (error) {
      this.outputChannel.appendLine(`[context-augmenter] Prompt augmentation error: ${error instanceof Error ? error.message : String(error)}`);
      return originalPrompt;
    }
  }
}